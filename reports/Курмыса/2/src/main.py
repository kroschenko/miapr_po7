from math import sin
from random import uniform

def f(x):
  return 2 * sin(9 * x) + 0.4

omega = [uniform(0, 1) for _ in range(3)] # коэффициенты
T = 0 # порог обучения
count_of_iterations = 1 # порядковый номер очередного прогона

Err_min = float(input('Введите максимально возможную квадратичную погрешность при обучении: '))
error_sum = 0 # для высчитывания итоговой среднеквадратической ошибки
last_err = 0 # для того что

print('Изначальные данные:\nИзначальные коэфф. -', omega, '\nПорог функции T -', T)
# обучение на максимум 100 итерациях, после которых мы получаем коэффициенты и T для непосредственного прогноза

print(f'Обучение:\nЭпоха # {"N":2}: {"Идеальное значение t":21} {"Полученное значение":21} {"Отклонение между знач.":26} {"Квадр. погр.":26}')
while count_of_iterations <= 100:
  for i in range(30):
    sum_sq_x = 0
    x = [f(j / 10) for j in range(i, i + 3)] # для обучения, проверять на практике будем другие значения
    X = (i + 3) / 10 # аргумент функции для проверки погрешности
    S = 0
    for j in range(3):
      S += omega[j] * x[j] # приближённое значение f(X) ч/з нейронные сети
      sum_sq_x += x[j]**2
    alpha = 1 / (1 + sum_sq_x) # вычисление адаптивного шага обучения в зависимости от суммы квадратов входных чисел
    t = f(X) # идеальное значение f(X) напрямую
    y = S - T
    delta = y - t
    err = delta**2 / 2
    error_sum += err
    if delta**2 / 2 < Err_min:
      break
    for j in range(3):
      omega[j] -= alpha * delta * x[j]
    T += alpha * delta
  if last_err != err:
    print(f'Эпоха # {count_of_iterations:2}: {t:21} {y:21} {delta:24} {err:24}')
    if error_sum / 30 <= Err_min:
      break
  last_err = err
  count_of_iterations += 1

print('\nПосле обучения имеем следующие конфигурации:\nКоэффициенты =', omega, '\nПорог функции T =', T)
print('\nПроводим тестирование/предсказание значения функции на 15-ти случайных рациональных значениях от -100 до 100:')
test_number = 1 # номер теста
error_sum = 0 # для высчитывания итоговой среднеквадратической ошибки
print(f'Тестирование:\nЭпоха # {"N":2}: {"Идеальное значение t":21} {"Полученное значение":21} {"Отклонение между знач.":26} {"Квадр. погр.":26}')
while test_number <= 15:
  X = uniform(-100, 100) # аргумент для тестирования
  x = [f(X - 0.3), f(X - 0.2), f(X - 0.1)] # значения x для генерации ответа
  ideal = f(X) # идеальное значение функции
  S = 0 # сумматор произведений
  for i in range(3):
    S += x[i] * omega[i]
  y = S - T
  delta = y - ideal
  err = delta**2 / 2
  error_sum += err
  print(f'Эпоха # {test_number:2}: {ideal:21} {y:21} {delta:24} {err:24}')
  test_number += 1

avg_error = error_sum / 15 # среднеквадратическая погрешность
print('\nСреднеквадратическая погрешность равна', avg_error)
